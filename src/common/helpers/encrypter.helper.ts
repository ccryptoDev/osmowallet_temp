import { BadRequestException } from '@nestjs/common';
import { createDecipheriv, createCipheriv, randomBytes, scrypt, scryptSync } from 'crypto';
import { promisify } from 'util';

export default class EncrypterHelper{
    private algorithm: string = 'aes-256-ctr';
    private ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
    //The IV was generated by randombytes(16)
    private iv = Buffer.from(process.env.ENCRYPTION_IV,'hex')
    private key
    constructor(){
      this._initKey()
    }

    async _initKey(){
      this.key = (await promisify(scrypt)(this.ENCRYPTION_KEY, 'salt', 32)) as Buffer;
    }

    async encrypt(textToEncrypt: string){
      this.key = (await promisify(scrypt)(this.ENCRYPTION_KEY, 'salt', 32)) as Buffer;
      const cipher = createCipheriv(this.algorithm, this.key, this.iv);
      const encryptedText = Buffer.concat([
        cipher.update(textToEncrypt),
        cipher.final(),
      ]);
      return encryptedText.toString('hex');
    }
    
    async decrypt(encryptedText: any){
      this.key = (await promisify(scrypt)(this.ENCRYPTION_KEY, 'salt', 32)) as Buffer;
      const decipher = createDecipheriv(this.algorithm, this.key, this.iv);
      const decryptedText = Buffer.concat([
        decipher.update(encryptedText,'hex'),
        decipher.final(),
      ]);
      return decryptedText.toString('utf8');
    }

    async encryptPayload(textToEncrypt: string) : Promise<string>{
      const iv = Buffer.from(process.env.PAYLOAD_ENCRYPTION_IV,'hex');
      const cipher = createCipheriv('aes-256-ctr', Buffer.from(process.env.PAYLOAD_ENCRYPTION_KEY), iv);
      let encrypted = cipher.update(textToEncrypt);
      encrypted = Buffer.concat([encrypted, cipher.final()]);
      return encrypted.toString('hex');
    }
  

    async decryptPayload(encrypted: string): Promise<string> {
      const content = encrypted;
      const iv = Buffer.from(process.env.PAYLOAD_ENCRYPTION_IV,'hex');
      const decipher = createDecipheriv('aes-256-ctr', Buffer.from(process.env.PAYLOAD_ENCRYPTION_KEY), iv);
      let decrypted = decipher.update(Buffer.from(content, 'hex'));
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return decrypted.toString('utf8');
    }

    async decryptRocket(rocket: string) {
      const rocketDecrypted = await this.decryptPayload(rocket)
      const value = Number.parseFloat(rocketDecrypted)
      try {
        if (typeof value !== 'number') {
          throw new BadRequestException('Unknow error');
        }
      } catch (error) {
        throw new BadRequestException('Unknow error');
      }
      return value;
    }
}